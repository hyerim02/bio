---
title: "CH6"
date: "2023-08-16"
output:
  pdf_document:
    latex_engine: xelatex
  word_document: default
mainfont: NanumGothic
---

```{r,message = FALSE}
library(tidyverse)
dt <- read.csv("C:\\Users\\phl02\\Desktop\\P\\bio\\ch6\\Ch6_regression.csv")
head(dt)
``` 


# 1. 회귀 분석
## 1.1 단순 선형 회귀 분석
### 1) 상관관계 알아보기 
```{r}
plot(osm~na, data=dt)
```  
\newpage  

### 2) 회귀식 추정 
```{r}
fit<-lm(osm~na, data = dt)
fit
``` 

```{r}
plot(osm~na, data=dt)
abline(fit, col='red', lwd=2)
```  
\newpage

### 3) 결정계수 찾고 4)유의한 회귀식 모형인지 검증
```{r}
summary(fit)
```
\newpage

### 6) 기본 가정이 충족하는지 확인
```{r}
par(mfrow=c(2,2))
plot(fit)
```
\newpage

## 1.2 다중 회귀 분석
### 1) 산점도 이용하여 데이터 분포 살펴보기 
```{r}
par(mfrow=c(2,2))
plot(osm~bun, data=dt, main="BUN")
plot(osm~glucose, data=dt, main="Glucose")
plot(osm~height, data=dt, main="Height")
plot(osm~weight, data=dt, main="Weight")
```
\newpage

### 2) 다중 선형 회귀식 추정 
```{r}
fit.multi<-lm(osm~na+bun+glucose+height+weight, data=dt)
fit.multi
```

### 3) 유의성 및 결정계수 검정
```{r}
summary(fit.multi)
```
\newpage

### 4) 가정 검정
```{r}
par(mfrow=c(2,2))
plot(fit.multi)
```

\newpage

### 6) 선택의 기준: AIC 

```{r}
fit1<-lm(osm~na, data=dt)
f1<-summary(fit1)
f1$adj.r.squared
```    
```{r}
fit2<-lm(osm~na+bun, data=dt)
f2<-summary(fit2)
f2$adj.r.squared
```    
```{r}
fit3<-lm(osm~na+bun+glucose, data=dt)
f3<- summary(fit3)
f3$adj.r.squared
```    
```{r}
fit4<-lm(osm~na+bun+glucose+height, data=dt)
f4<-summary(fit4)
f4$adj.r.squared
```    
```{r}
fit5<-lm(osm~na+bun+glucose+height+weight, data=dt)
f5<-summary(fit5)
f5$adj.r.squared
```  
\newpage  

- 한 번에 하는 방법

```{r}
fit.multi<-lm(osm~na+bun+glucose+height+weight, data=dt)
step(fit.multi)
```  
\newpage  

### 7) 또 다른 방법 

```{r,message=FALSE}
library(olsrr)

fit.multi<-lm(osm~na+bun+glucose+height+weight, data=dt)
```  
- 모델 평가 
```{r}
ols_step_all_possible(fit.multi)
```  
\newpage  

- 단계적 선택법으로 모델 비교
```{r}
ols_step_best_subset(fit.multi)
```  
\newpage  

- 전진 선택법 
```{r}
ols_step_forward_aic(fit.multi)
plot(ols_step_forward_aic(fit.multi))+theme_bw()
```  
\newpage  

- 후진 선택법 
```{r}
ols_step_backward_aic(fit.multi)
plot(ols_step_backward_aic(fit.multi))+theme_bw()
```    
\newpage  

# 2. 일반화 선형 분석
## 2.1 로지스틱 회귀 분석
### 1) 로지스틱 회귀분석의 기본 

```{r message=FALSE}
dt1<-read_csv("C:\\Users\\phl02\\Desktop\\P\\bio\\ch6\\Ch6_logistic.csv")
head(dt1)
```  
\newpage  

```{r}
plot(dt1$id, dt1$group)
```  

\newpage   

### 4) 우도비검정 

```{r,message=FALSE,warning=FALSE}
library(moonBook)
mytable(group~aspirin+ibd+diabetes+gender+age, data=dt1)
```  
\newpage   

### 5) 공식

```{r}
fit<-glm(group~age+gender+ibd+cirrhosis+diabetes+htn+aspirin, 
         family=binomial, data=dt1)
fit
```
\newpage   

```{r}
summary(fit)
```  
\newpage   

### 6) 유의한 독립변수만 포함 

```{r}
step(fit, type='backward')

final.fit<-glm(group~age+ibd+cirrhosis+aspirin, 
               family=binomial, data=dt1)
```    
```{r}
extractOR(final.fit)
```  
\newpage  

### 7) 회귀모형 평가 
```{r}
library(fmsb)
NagelkerkeR2(final.fit)
```
\newpage 

## 2.2 모형의 성능
```{r}
library(performance)
library(see)
library(patchwork)
```
### 1) Nagelkerke 결정계수
```{r}
r2_nagelkerke(final.fit)
```

### 2) Hosmer-Lemeshow goodness-of fit test

```{r}
performance_hosmer(final.fit)
```
\newpage   

### 3) 회귀모형 가정에 위배되는지 확인 
```{r fig.height=10,fig.width=10}
fit<-lm(osm~na+bun+glucose+height+weight, data=dt)
check_model(fit)
```  

\newpage  

### 4) 더 나은 모형 선택
```{r}
model_performance(fit)
```
```{r}
fit<-lm(osm~na+bun+glucose+height+weight, data=dt)
fit1<-lm(osm~na+bun+glucose, data=dt)
compare_performance(fit, fit1, rank = TRUE)
```

\newpage  

# 3. ROC 관련 분석
## 3.4 ROC 곡선 직접 그려보기

```{r,message=FALSE}
roc.ex<-read_csv("C:\\Users\\phl02\\Desktop\\P\\bio\\ch6\\Ch6_afp.csv")
head(roc.ex)
```


\newpage  

편의상 afp변수를 내림차순으로 정렬  
간암/정상: 10명
```{r}
roc.ex<-roc.ex %>% 
  arrange(desc(afp))
roc.ex
```

\newpage  

3.4 부분은 책에서 코드 없이 예시로만 보여줘서 직접했음
```{r warning=FALSE}
library(ggplot2)
ggplot(roc.ex,aes(x=afp,fill=factor(group)))+
  geom_density(alpha=0.5)+xlim(0,20)
```  

\newpage  
```{r}
sensitivity <-c(0,0.1,0.2,0.3,0.8,0.9,1,1)
FPR <-1-c(1,1,1,0.9,0.9,0.8,0.6,0)
result <- data.frame(cbind(sensitivity,FPR))
ggplot(result,aes(x=FPR,y=sensitivity))+geom_point()+
  geom_line()+
  geom_abline(intercept = 0,slope = 1,color='red',linetype=3)
```  
\newpage  

## 3.5 pROC 패키지
### 1) ROC 객체 생성 
```{r message=FALSE}
library(pROC)
afp<-roc(roc.ex$group, roc.ex$afp, ci=TRUE)
afp
```
\newpage 

```{r}
plot(afp)
```

\newpage

```{r message=FALSE}
afp<-roc(roc.ex$group, roc.ex$afp)
plot(afp,legacy.axes=TRUE)
```  
\newpage  

### 2) 겹쳐 그리기 
```{r message=FALSE}
afp<-roc(roc.ex$group, roc.ex$afp)
pivka<-roc(roc.ex$group, roc.ex$pivka)
plot(afp, col='blue', legacy.axes=TRUE)
plot(pivka, col='red', legacy.axes=TRUE, add=TRUE)
legend(0.3, 0.2, legend=c("AFP", "PIVKA"),
       col=c("blue", "red"), lty=1:1, cex=0.8)
```
\newpage  

### 3) ROC비교
```{r}
roc.test(afp, pivka)
```  

### 4) 최적의 cut-off 찾기
```{r}
ci.thresholds(afp, conf.level=0.95, boot.n=1000,
              thresholds='best')
```  
\newpage  

### 5) 특정 cut-off에서 민감도, 특이도 계산하기
```{r}
metric<-c('sensitivity','specificity','ppv','npv')

afp.cutoff<-ci.coords(afp, x=5, input="threshold", metric)
afp.cutoff
```  

- 민감도
```{r}
afp.cutoff$sensitivity
```  
- 특이도  
```{r}
afp.cutoff$specificity
```  
- ppv  
```{r}
afp.cutoff$ppv
```  
- npv
```{r}
afp.cutoff$npv
```
\newpage 

## 3.6 Epi 패키지
```{r message=FALSE,warning=FALSE}
library(Epi)
roc.ex$new_gr<-ifelse(roc.ex$group=='HCC',1,0)
ROC(form=new_gr~afp, data=roc.ex, plot='ROC')
```
\newpage   

```{r warning=FALSE}
ROC(form=new_gr~pivka, data=roc.ex, plot='ROC')
```
\newpage  

### 1) 2개 진단검사를 포함한 ROC 
```{r warning=FALSE}
ROC(form=new_gr~afp+pivka, data=roc.ex, plot='ROC')
```
\newpage  

# 4. 생존 분석
## 4.1 Time to event 분석
### 2) 생존함수와 위험함수 
```{r message=FALSE}
library(survival)
library(lubridate)
suv.dt<-read_csv('C:\\Users\\phl02\\Desktop\\P\\bio\\ch6\\Ch6_survival.csv')
suv.dt
```
\newpage

### 3) 추적관찰기간 계산 
```{r message=FALSE}
suv.dt$hcc_period <- suv.dt$hcc_date - suv.dt$start_date
suv.dt$hcc_period <- as.numeric(suv.dt$hcc_period)
summary(suv.dt$hcc_period)
```
day 단위를 year 단위로 
```{r}
suv.dt$hcc_period <- suv.dt$hcc_period / 365.25
summary(suv.dt$hcc_period)
```
한 번에 코드로 
```{r, eval=FALSE}
suv.dt <- suv.dt %>% 
  mutate(hcc_period = hcc_date - start_date) %>% 
  mutate(hcc_period = as.numeric(hcc_period)/365.25)
```
\newpage  

```{r message=FALSE}
library(ggpubr)

suv.dt1 <- suv.dt %>% 
  mutate(hcc_period = hcc_date - start_date) %>% 
  mutate(hcc_period = as.numeric(hcc_period)/365.25)%>%
  mutate(hcc_period=round(hcc_period,2))%>%
  mutate(hcc = factor(hcc))

ggbarplot(suv.dt1,y='hcc_period',x='id',fill='hcc',sort.val = 'asc',
          sort.by.groups = F, label = TRUE,lab.pos = "in",orientation = "horiz")
```
\newpage

## 4.2 Kaplan-Meier 곡선
### 1) 생존함수 객체 만들기
```{r}
f1<-survfit(Surv(hcc_period, hcc)~1, data=suv.dt)
plot(f1,
     xlab='Obervation period',
     ylab='Survival probability')
```
\newpage

### 2) survminer패키지 
```{r message=FALSE}
library(survminer)
ggsurvplot(f1, risk.table = TRUE)
```

\newpage  

## 4.3 5년 생존율 계산
```{r}
summary(f1,times=5)
```
그래프로 확인
```{r}
plot(f1, conf.int=FALSE)
points(x=5, y=0.665, pch=19)
segments(5,-0.1, 5,0.665, col='red')
segments(-1,0.665, 5,0.665,col='red', lty=2)
text(x=0+0.1, y=0.665+0.1, labels=c('66.5%'), col='red')
```
\newpage  

## 4.4 Median survival 계산
```{r}
median(suv.dt$hcc_period)
```
중도절단을 고려하지 않았기 때문에 단순한 중위 생존기간을 계산하면 틀림
```{r}
f1
```
```{r}
plot(f1, conf.int=FALSE)
points(x=8, y=0.5, pch=19)
segments(8,-0.1, 8,0.5, col='red')
segments(-1,0.5, 8,0.5,col='red', lty=2)
text(x=8, y=0.6, labels=c('50.0%'), col='red')
```
\newpage  

## 4.5 두그룹에서 생존 함수 비교
- log-rank test
```{r}
survdiff(Surv(hcc_period, hcc)~lc, data=suv.dt)
```
```{r}
f2<-survfit(Surv(hcc_period, hcc)~lc, data=suv.dt)
plot(f2, conf.int=FALSE, col=c('blue','red'))
text(x=9, y=0.8, labels=c('lc=0'), col='blue')
text(x=9, y=0.2, labels=c('lc=1'), col='red')
```
\newpage  

## 4.6 Survminer 패키지
```{r message=FALSE}
suv.dt1<-read_csv('C:\\Users\\phl02\\Desktop\\P\\bio\\ch6\\Ch6_survival1.csv')
dim(suv.dt1)
```
```{r}
head(suv.dt1)
```
\newpage

### 1) 가장 기본 km곡선 그리기 
```{r}
f1<-survfit(Surv(death_yr, death)~1, data=suv.dt1)
ggsurvplot(f1)
```
\newpage

```{r}
f1.hcc<-survfit(Surv(death_yr, death)~hcc, data=suv.dt1)
ggsurvplot(f1.hcc)
```
\newpage  

### 2) 누적 발생률 
```{r}
f2<-survfit(Surv(death_yr, death)~1, data=suv.dt1)
ggsurvplot(f2,
           conf.int = FALSE,
           fun = 'event',
           ylim=c(0,1),
           ggtheme=theme_bw())
```
\newpage 

```{r fig.height=10,fig.width=10 }
f2.hcc<-survfit(Surv(death_yr, death)~hcc, data=suv.dt1)
ggsurvplot(f2.hcc,
           fun='event',
           pval=TRUE,
           risk.table='abs_pct',
           palette=c('red','blue'),
           break.time.by=1,
           legend='top',
           legend.title='HCC',
           legend.labs=c('None','Present'),
           xlab=c('Years after treatment'),
           ylab=c('Cumulative incidence of HCC'),
           ylim=c(0,1),
           surv.median.line = 'hv',
           ncensor.plot=TRUE)
```
\newpage

## 4.7 Cox 비례위험모형
### 1) cox model 
```{r message=FALSE}
library(moonBook)
suv.dt2 <-read_csv('C:\\Users\\phl02\\Desktop\\P\\bio\\ch6\\Ch6_survival2.csv')

f1.lc<-coxph(Surv(hcc_yr, hcc)~lc, data=suv.dt2)
extractHR(f1.lc)
```  
```{r}
f1.lc<-survfit(Surv(hcc_yr, hcc)~lc, data=suv.dt2)
ggsurvplot(f1.lc,
           fun='event',
           pval=TRUE,
           risk.table=TRUE,
           break.time.by=1,
           xlab=c('Year after treatment'),
           ylab=c('Cumulative incidence of HCC'),
           ylim=c(0,1))
```

\newpage

## 4.8 Cox 모형을 이용하여 단변량, 다변량 분석
### 1) moonBook 패키지- 단변량  
```{r}
suv.dt2$TS<-Surv(suv.dt2$hcc_yr,suv.dt2$hcc)
mycph(TS~gender+age+lc+dm+hbeag, data=suv.dt2)
```
### 2) gtsummary 패키지 - 단변량 
```{r message=FALSE}
library(gtsummary)
suv.dt2 %>% 
  select(-id, -TS, -death, -death_yr) %>% 
  tbl_uvregression(method=coxph,
                   y=Surv(hcc_yr, hcc),
                   exponentiate=TRUE)
```
\newpage

### 3) 다변량 분석 결과 제시 
```{r}
f1.multi<-coxph(Surv(hcc_yr,hcc)~age+gender+lc+dm+hbeag, data=suv.dt2)
extractHR(f1.multi)
```
\newpage

```{r}
f1.final<-step(f1.multi, direction = 'backward')
extractHR(f1.final)
```
\newpage

### 4) gtsummary 패키지- 다변량 

```{r message=FALSE}
cox.uni<-suv.dt2 %>% 
  select(hcc, hcc_yr, age, gender, lc, dm, hbeag) %>% 
  tbl_uvregression(method=coxph,
                   y=Surv(hcc_yr, hcc),
                   exponentiate = TRUE)
cox.uni
```
\newpage

```{r message=FALSE}
cox.multi<-coxph(Surv(hcc_yr, hcc)~age+lc, data=suv.dt2) %>% 
  tbl_regression(exponentiate=TRUE)
cox.multi
```
\newpage

```{r message=FALSE}
cox.table<-tbl_merge(
  tbls = list(cox.uni, cox.multi),
  tab_spanner = c("**Univariate analysis**","**Multivariable analysis**")
)
cox.table
```
\newpage

## 4.9 Forest plot 그리기
```{r eval=FALSE}
library(forestmodel)
f1.cox<-coxph(Surv(hcc_yr, hcc==1)~age+gender+lc+dm+hbeag, data=suv.dt2)
ggforest(f1.cox)
```


\newpage

## 4.10 Cox 모형 검증
```{r}
f1.cox<-coxph(Surv(hcc_yr, hcc==1)~age+gender+lc+dm+hbeag, data=suv.dt2)
cox.zph(f1.cox)
```
\newpage
```{r fig.height=10,fig.width=10}
ftest<-cox.zph(f1.cox)
ggcoxzph(ftest)
```
\newpage  

# 5 Time dependent Cox model
```{r message=FALSE}
dt.time<-read_csv('C:\\Users\\phl02\\Desktop\\P\\bio\\ch6\\Ch6_survival3.csv')
head(dt.time)
```
\newpage

```{r fig.height=10,fig.width=10}
f1.hcc<-survfit(Surv(hcc_yr, hcc)~alt_nl, data=dt.time)

ggsurvplot(f1.hcc,
           fun='event',
           risk.table=TRUE,
           break.time.by=1,
           xlim=c(0,5),
           ylim=c(0,0.3),
           pval = TRUE)
```
\newpage

```{r message=FALSE}
dt.time1<-tmerge(dt.time, dt.time, id=id, HCC=event(hcc_yr, hcc))

dt.time1<-tmerge(dt.time1, dt.time1, id=id, ALT=tdc(alt_duration, alt_nl))

dt.time1$ALT[is.na(dt.time1$ALT)]<-c('abnormal')

head(dt.time[,c('id','hcc_yr','hcc','alt_nl','alt_duration')])
```
```{r}
head(dt.time1[,c('id','hcc_yr','hcc','alt_nl','alt_duration','tstart','tstop','HCC','ALT')],11)
```
```{r}
f1.time<-coxph(Surv(tstart, tstop, HCC==1)~ALT+cluster(id), data=dt.time1)
extractHR(f1.time)
```


